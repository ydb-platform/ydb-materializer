# Руководство разработчика YDB Materializer

Задача: обеспечить эффективное выполнение ad-hoc (генерируемых) запросов с простыми фильтрами (равенство, диапазон значений, префикс) и сортировкой, с выдачей первых 100 записей. Запросы формирует интерактивное приложение, критерии фильтрации задаёт пользователь в интерфейсе.

Структура данных нормализованная, атрибуты для фильтрации "разбросаны" по разным таблицам. Некоторые из таблиц "большие" (миллионы и миллиарды строк), некоторые — заведомо "маленькие" и редко меняющиеся (до тысяч строк, справочники).

Предлагаемый подход: материализовать все необходимые атрибуты в одной таблице. Материализацию обновлять в асинхронном режиме с использованием потоков данных Change Data Capture.

## Обзор проекта для разработчиков

- Главный класс: `tech.ydb.mv.App`. Артефакт: `tech.ydb.apps:ydb-materializer` (версия в `pom.xml`).
- Сборка и дистрибутив: `mvn package` создаёт JAR и `*-bin.zip` (см. `src/main/assembly/zip.xml`).
- Тесты: JUnit 5, `ydb-junit5-support`, Testcontainers; запуск: `mvn test` (переменные окружения — в `pom.xml`).
- Зависимости: YDB SDK BOM 2.3.30, ANTLR 4.13.2, Log4j2, Gson, Prometheus metrics.

Требования, использование, режимы, конфигурация и встраивание — в **README.md**.

## Структура кода

```
src/main/java/tech/ydb/mv/
├── App.java              # Точка входа, выбор режима, режим JOB (Runner + Coordinator)
├── MvApi.java            # Публичный API (реализация — MvService)
├── MvConfig.java         # Константы, режимы, ключи конфигурации, перечисления (Input, Mode, PartitioningStrategy)
├── YdbConnector.java     # Подключение к YDB и аутентификация
├── apply/                # Применение изменений к таблицам MV
│   ├── MvApply*.java     # Менеджер, воркеры, очередь задач, список действий
│   ├── ActionSync.java   # Чтение источника по ключам → UPSERT в MV
│   ├── ActionKeysGrab.java, ActionKeysTransform.java, ActionKeysFilter.java
│   └── MvWorkerSelector.java
├── data/                 # Ключи, кортежи, записи об изменениях, вспомогательные типы для значений YDB
├── feeder/               # Приём изменений (CDC и сканирование)
│   ├── MvCdcFeeder.java, MvCdcAdapter.java, MvCdcEventReader.java, MvCdcParser.java
│   ├── MvScanFeeder.java, MvScanContext.java, MvScanCompletion.java
│   └── MvSink.java, MvCommitHandler.java, MvCdcCommitHandler.java, MvScanCommitHandler.java
├── mgt/                  # Распределённое управление заданиями
│   ├── MvRunner.java     # Регистрация в mv_runners, опрос mv_commands, запуск/остановка обработчиков через MvApi
│   ├── MvCoordinator.java, MvCoordinatorImpl.java, MvCoordinatorActions.java
│   ├── MvJobDao.java     # Все операции с БД для mv_jobs, mv_runners, mv_runner_jobs, mv_commands, mv_job_scans
│   ├── MvBatchSettings.java  # Имена таблиц и тайминги (период сканирования, отчёта, таймауты)
│   ├── MvBalancer.java   # Назначение заданий раннерам
│   └── MvCommand.java, MvJobInfo.java, MvRunnerInfo.java, MvRunnerJobInfo.java, MvJobScanInfo.java
├── metrics/              # Prometheus (MvMetrics: HTTP-сервер, JVM-метрики, счётчики/гистограммы)
├── model/                # Модель метаданных (представления, обработчики, таблицы, колонки, замечания, настройки)
├── parser/               # SQL-подобный язык и валидация
│   ├── MvSqlParser.java       # Парсер на ANTLR, формирует MvMetadata (представления + обработчики)
│   ├── MvSqlGen.java          # Генерация SELECT, UPSERT, типов ключей, CREATE TABLE
│   ├── MvStreamBuilder.java   # DDL для создания CDC-потоков
│   ├── MvDescriber.java, MvDescriberYdb.java, MvDescriberMeta.java  # Метаданные таблиц/колонок из YDB
│   ├── MvValidateBasic.java   # Структурная валидация (без обращения к БД)
│   ├── MvValidateSql.java     # Проверка сгенерированного SQL выполнением на YDB
│   ├── MvPathGenerator.java   # Утилиты для путей ключей и колонок
│   └── (генерируемые) YdbMatViewV1*.java из antlr4/.../YdbMatViewV1.g4
├── support/              # Чтение конфигурации, DAO-хелперы, вывод замечаний/SQL, адаптер/DAO сканирования
└── svc/                  # Слой сервисов
    ├── MvService.java         # Реализация MvApi: загрузка метаданных, обработчики, справочники, запуск/остановка
    ├── MvJobController.java   # Контроллер на обработчик (пайплайн CDC + apply)
    ├── MvJobContext.java       # Контекст обработчика для apply
    ├── MvDictionaryLogger.java # Запись изменений справочников в таблицу-журнал
    ├── MvDictionaryScan.java   # Чтение журнала справочников и запуск обновлений MV
    ├── MvLocker.java           # Распределённая блокировка (YDB Coordination)
```

## Архитектурные заметки

Основные компоненты:
1. **Модель данных** для описания материализованного представления
2. **Парсер** конфигурационного формата (SQL-подобный язык)
3. **Валидатор** конфигурации и загрузчик метаданных таблиц YDB
4. **Компонент сбора изменений** (CDC и/или сканирование ключей)
5. **Компонент применения изменений** (очереди по воркерам, чтение по ключам, UPSERT в MV)
6. **Генератор SQL** (SELECT по ключам, UPSERT, CREATE TABLE, типы ключей)
7. **Сбор изменений справочников** (CDC в таблицу-журнал)
8. **Агрегатор изменений справочников** (чтение журнала и определение затронутых ключей MV)
9. **Распределённый планировщик** (MvRunner, MvCoordinator, таблицы mv_jobs / mv_runners / mv_commands и др.)

Целостность данных обеспечивается на построчном уровне (разные строки могут соответствовать разным моментам времени изменения основных таблиц, но внутри одной строки данные полностью согласованы). Гарантируется "итоговая" согласованность: при остановке изменений основных таблиц MV приходит в полностью согласованное состояние после завершения обработки всех записей об изменениях в changefeed.

Чтение и запись данных выполняется последовательно в разных транзакциях для исключения ошибок TLI в других пишущих транзакциях, которые меняют записи в исходных таблицах MV. Чтобы не допустить пропуски изменений, важно реализовать строго последовательную обработку записей об изменениях по каждому ключу. Это обеспечивается разделением обработки по диапазонам значений первичного ключа на основе структуры партиций основной таблицы-источника (стратегия RANGE или HASH задаётся в настройках). Для каждого диапазона обработка ведётся строго последовательно: сперва чтение исходных данных запросом, потом запись результата, потом переход к следующей порции.

### Модель данных

- **MvMetadata** — полный загруженный набор метаданных (представления, обработчики, таблицы, ошибки, предупреждения).
- **MvView** — материализованное представление; может состоять из нескольких частей (MvViewExpr), объединённых UNION ALL.
- **MvViewExpr** — одна часть MV: SQL-трансформация в виде соединения таблиц, проекции и опционального фильтра.
- **MvJoinSource** — одна из таблиц в составе SQL-трансформации.
- **MvJoinCondition** — условие соединения (AND в составе MvJoinSource для правой части).
- **MvComputation** — метод вычисления поля или условия (в т.ч. непрозрачное выражение YQL в `#[ ... ]#`).
- **MvLiteral** — целочисленная или строковая константа.
- **MvColumn** — описание выходной колонки и способа её получения.
- **MvHandler** — задание: список MV и входных таблиц с changefeed (STREAM/BATCH), опционально CONSUMER.
- **MvTableInfo**, **MvKeyInfo**, **MvKeyPrefix**, **MvKey** — метаданные таблиц и ключей.
- **MvIssue** — ошибка или предупреждение при разборе/валидации.
- **MvHandlerSettings**, **MvDictionarySettings**, **MvScanSettings** — настройки обработки (потоки, очереди, таймауты, партиционирование и т.д.).

### Парсер конфигурационного формата

Реализован на ANTLR v4 (грамматика `YdbMatViewV1.g4`). Разбирает SQL-подобный скрипт в объекты модели (MvView, MvHandler). Загрузка конфигурации — из файла или из таблицы YDB (настройки см. в README). Класс `MvConfigReader` вызывает парсер и возвращает `MvMetadata`.

### Валидатор конфигурации

После парсинга выполняется привязка к метаданным таблиц YDB через `MvDescriber` (MvDescriberYdb): загрузка описаний таблиц, связывание с MvJoinSource, проверка колонок и типов. Валидация выполняется в два этапа:

1. **MvValidateBasic** — структурные проверки без обращения к БД (ссылки на таблицы/колонки, согласованность).
2. **MvValidateSql** — для каждой части MV генерируются фрагменты SQL (SELECT по ключам, WHERE, выражения колонок) и проверяются выполнением на YDB (синтаксис и корректность). Критические ошибки останавливают дальнейшие фазы.

Вызов: `MvMetadata.linkAndValidate(MvDescriber)` (сначала заполняет `tables`, затем `validate(conn)`).

Ограничения/недоделки:
- Нет отдельного автомата проверки всех вариантов генерируемых запросов и методов доступа при различных сценариях соединений.

### Компонент сбора изменений

- **CDC**: чтение из топиков CDC (MvCdcFeeder, MvCdcAdapter, MvCdcEventReader, MvCdcParser), фиксация позиции через MvCdcCommitHandler.
- **Сканирование**: чтение ключей "самой левой" таблицы MV с ограничением интенсивности (MvScanFeeder, MvScanContext, MvScanCompletion), опциональный фильтр; позиция хранится в таблице (см. README). В распределённом режиме — таблица заданий на сканирование (MvJobDao, MvJobScanInfo).

### Компонент применения изменений

В рамках одного обработчика (MvHandler) активна обработка для набора MV. Обработку конкретного MV можно включать/выключать через API (startHandler/stopHandler — см. MvApi).

Используется N потоков (MvApplyWorker), у каждого своя входная очередь. Ключи "самой левой" таблицы распределяются по воркерам по значению первичного ключа (MvWorkerSelector). Очередь имеет ограничение по размеру в нормальном режиме; форсированный режим используется для внутренних преобразований (дозагрузка ключей, трансформации в памяти), чтобы избежать взаимоблокировок.

Периодически выполняется Describe "самой левой" таблицы и обновляются диапазоны ключей по воркерам (партиционирование RANGE/HASH).

Цикл обработчика:
1. Получить записи об изменениях из очереди (не более K штук).
2. Сгруппировать по таблицам и объектам подтверждения.
3. Определить состав обработчиков (список действий) и подать записи.
4. Подтвердить обработку (фиксация).

Типы действий (MvApplyAction):
- **ActionSync** — чтение данных по ключам (отдельная читающая транзакция), ожидание завершения предыдущей записи при необходимости, запись через `UPSERT INTO mv SELECT * FROM AS_TABLE($input)`.
- **ActionKeysTransform** — трансформация ключей без доступа к БД.
- **ActionKeysGrab** — чтение ключей из БД дополнительным запросом.
- **ActionKeysFilter** — фильтрация ключей.

### Генератор SQL-запросов

**MvSqlGen**: строит SQL на основе MvViewExpr — CREATE TABLE для MV, SELECT по ключам для чтения исходных данных, UPSERT из AS_TABLE. Поддерживает перестроение связей (порядок JOIN) для производных запросов. Вспомогательные константы: SYS_KEYS, SYS_INPUT и др. Типы ключей и строк (StructType) выводятся из модели.

### Сбор изменений справочников

Для таблиц-справочников, используемых в MV, CDC-потоки собираются в режиме BOTH_IMAGES или UPDATES. Изменения записываются в таблицу-журнал (MvDictionaryLogger): таблица-источник, метка времени, первичный ключ, изменённые поля (настройки журнала и потребителя — в README). На журнал рекомендуется TTL. Сбор выполняется централизованно в рамках задания **ydbmv$dictionary** (MvConfig.HANDLER_DICTIONARY).

### Агрегатор изменений справочников

**MvDictionaryScan**: читает журнал изменений справочников, определяет затронутые ключи основного потока и передаёт их в конвейер применения для соответствующего обработчика. Используются запросы с пагинацией по (src, tv, seqno, key_text).

### Распределённый планировщик (MvRunner, MvCoordinator)

- В каждом процессе — экземпляр **MvRunner**: регистрируется в таблице `mv_runners`, периодически обновляет свой статус, опрашивает `mv_commands` и по командам запускает/останавливает обработчики через MvApi (startHandler/stopHandler). Запущенные задания фиксирует в `mv_runner_jobs`.
- **MvCoordinator** должен работать в единственном экземпляре глобально. Лидер выбирается через YDB Coordination (MvLocker) по имени **ydbmv$coordinator** (MvConfig.HANDLER_COORDINATOR). Координатор периодически сканирует `mv_jobs`, `mv_runners`, `mv_runner_jobs`; удаляет неактивных раннеров и связанные записи; добавляет команды в `mv_commands` для запуска недостающих заданий и остановки лишних. Имена **ydbmv$dictionary** и **ydbmv$coordinator** зарезервированы и не должны использоваться для обычных MvHandler.

Настраиваемые имена таблиц и периоды задаются через **MvBatchSettings** (загрузка из Properties; полный список параметров — в README, раздел «Настройки управления»). Схемы таблиц `mv/jobs`, `mv/runners`, `mv/runner_jobs`, `mv/commands`, `mv/job_scans` и описание работы координатора и раннеров — в README, раздел «Распределённое управление заданиями (режим JOB)».

При успешном выполнении команды MvRunner обновляет статус в `mv_commands` на SUCCESS и добавляет/удаляет запись в `mv_runner_jobs`; при ошибке — command_status = ERROR, в command_diag пишется диагностика.

## Мониторинг

Метрики Prometheus реализованы в `tech.ydb.mv.metrics.MvMetrics`. Параметры включения и список метрик — в README (раздел параметров конфигурации → метрики, перечень собираемых метрик). Стек Prometheus + Grafana — в `monitoring/README.md`.

## Встраивание

Публичный API: **MvApi** / **MvService** (`MvApi.newInstance(YdbConnector)`). Использование при встраивании библиотеки и зависимость Maven — в README.
