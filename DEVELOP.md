# Руководство разработчика YDB Materializer

Задача: обеспечить эффективное выполнение ad-hoc (генерируемых) запросов с простыми фильтрами (равенство, диапазон значений, префикс) и сортировкой, с выдачей первых 100 записей. Запросы формирует интерактивное приложение, критерии фильтрации задаёт пользователь в интерфейсе.

Структура данных нормализованная, атрибуты для фильтрации "разбросаны" по разным таблицам. Некоторые из таблиц "большие" (миллионы и миллиарды строк), некоторые — заведомо "маленькие" и редко меняющиеся (до тысяч строк, справочники).

Предлагаемый подход: материализовать все необходимые атрибуты в одной таблице. Материализацию обновлять в асинхронном режиме с использованием потоков данных Change Data Capture.

## Обзор проекта для разработчиков

- Главный класс: `tech.ydb.mv.App`. Артефакт: `tech.ydb.apps:ydb-materializer` (версия в `pom.xml`).
- Сборка и дистрибутив: `mvn package` создаёт JAR и `*-bin.zip` (см. `src/main/assembly/zip.xml`).
- Тесты: JUnit 5, `ydb-junit5-support`, Testcontainers; запуск: `mvn test` (переменные окружения — в `pom.xml`).
- Зависимости: YDB SDK BOM 2.3.30, ANTLR 4.13.2, Log4j2, Gson, Prometheus metrics.

Требования, использование, режимы, конфигурация и встраивание — в **README.md**.

## Структура кода

```
src/main/java/tech/ydb/mv/
├── App.java              # Точка входа, выбор режима, режим JOB (Runner + Coordinator)
├── MvApi.java            # Публичный API (реализация — MvService)
├── MvConfig.java         # Константы, режимы, ключи конфигурации, перечисления (Input, Mode, PartitioningStrategy)
├── YdbConnector.java     # Подключение к YDB и аутентификация
├── apply/                # Применение изменений к таблицам MV
│   ├── MvApply*.java     # Менеджер, воркеры, очередь задач, список действий
│   ├── MvApplyActionList.java  # Цепочка действий для обработки изменений
│   ├── ActionSync.java   # Чтение источника по ключам → UPSERT в MV
│   ├── ActionKeysGrab.java, ActionKeysTransform.java, ActionKeysFilter.java
│   └── MvWorkerSelector.java
├── data/                 # Ключи, кортежи, записи об изменениях, вспомогательные типы для значений YDB
├── feeder/               # Приём изменений (CDC и сканирование)
│   ├── MvCdcFeeder.java, MvCdcAdapter.java, MvCdcEventReader.java, MvCdcParser.java
│   ├── MvScanFeeder.java, MvScanContext.java, MvScanCompletion.java
│   └── MvSink.java, MvCommitHandler.java, MvCdcCommitHandler.java, MvScanCommitHandler.java
├── mgt/                  # Распределённое управление заданиями
│   ├── MvRunner.java     # Регистрация в mv_runners, опрос mv_commands, запуск/остановка обработчиков через MvApi
│   ├── MvCoordinator.java, MvCoordinatorImpl.java, MvCoordinatorActions.java
│   ├── MvJobDao.java     # Все операции с БД для mv_jobs, mv_runners, mv_runner_jobs, mv_commands, mv_job_scans
│   ├── MvBatchSettings.java  # Имена таблиц и тайминги (период сканирования, отчёта, таймауты)
│   ├── MvBalancer.java   # Назначение заданий раннерам
│   └── MvCommand.java, MvJobInfo.java, MvRunnerInfo.java, MvRunnerJobInfo.java, MvJobScanInfo.java
├── metrics/              # Prometheus (MvMetrics: HTTP-сервер, JVM-метрики, счётчики/гистограммы)
├── model/                # Модель метаданных (представления, обработчики, таблицы, колонки, замечания, настройки)
├── parser/               # SQL-подобный язык и валидация
│   ├── MvSqlParser.java       # Парсер на ANTLR, формирует MvMetadata (представления + обработчики)
│   ├── MvSqlGen.java          # Генерация SELECT, UPSERT, типов ключей, CREATE TABLE
│   ├── MvStreamBuilder.java   # DDL для создания CDC-потоков
│   ├── MvDescriber.java, MvDescriberYdb.java, MvDescriberMeta.java  # Метаданные таблиц/колонок из YDB
│   ├── MvValidateBasic.java   # Структурная валидация (без обращения к БД)
│   ├── MvValidateSql.java     # Проверка сгенерированного SQL выполнением на YDB
│   ├── MvPathGenerator.java   # Построение минимальных трансформаций ключей между источниками
│   └── (генерируемые) YdbMatViewV1*.java из src/main/antlr4/tech/ydb/mv/parser/YdbMatViewV1.g4
├── support/              # Чтение конфигурации, DAO-хелперы, вывод замечаний/SQL, адаптер/DAO сканирования
└── svc/                  # Слой сервисов
    ├── MvService.java         # Реализация MvApi: загрузка метаданных, обработчики, справочники, запуск/остановка
    ├── MvJobController.java   # Контроллер на обработчик (пайплайн CDC + apply)
    ├── MvJobContext.java       # Контекст обработчика для apply
    ├── MvDictionaryLogger.java # Запись изменений справочников в таблицу-журнал
    ├── MvDictionaryScan.java   # Чтение журнала справочников и запуск обновлений MV
    ├── MvLocker.java           # Распределённая блокировка (YDB Coordination)
```

## Архитектурные заметки

Основные компоненты:
1. **Модель данных** для описания материализованного представления
2. **Парсер** конфигурационного формата (SQL-подобный язык)
3. **Валидатор** конфигурации и загрузчик метаданных таблиц YDB
4. **Компонент сбора изменений** (CDC и/или сканирование ключей)
5. **Компонент применения изменений** (очереди по воркерам, чтение по ключам, UPSERT в MV)
6. **Генератор SQL** (SELECT по ключам, UPSERT, CREATE TABLE, типы ключей)
7. **Сбор изменений справочников** (CDC в таблицу-журнал)
8. **Агрегатор изменений справочников** (чтение журнала и определение затронутых ключей MV)
9. **Распределённый планировщик** (MvRunner, MvCoordinator, таблицы mv_jobs / mv_runners / mv_commands и др.)

Целостность данных обеспечивается на построчном уровне (разные строки могут соответствовать разным моментам времени изменения основных таблиц, но внутри одной строки данные полностью согласованы). Гарантируется "итоговая" согласованность: при остановке изменений основных таблиц MV приходит в полностью согласованное состояние после завершения обработки всех записей об изменениях в changefeed.

Чтение и запись данных выполняется последовательно в разных транзакциях для исключения ошибок TLI в других пишущих транзакциях, которые меняют записи в исходных таблицах MV. Чтобы не допустить пропуски изменений, важно реализовать строго последовательную обработку записей об изменениях по каждому ключу. Это обеспечивается разделением обработки по диапазонам значений первичного ключа на основе структуры партиций основной таблицы-источника (стратегия RANGE или HASH задаётся в настройках). Для каждого диапазона обработка ведётся строго последовательно: сперва чтение исходных данных запросом, потом запись результата, потом переход к следующей порции.

### Модель данных

- **MvMetadata** — полный загруженный набор метаданных (представления, обработчики, таблицы, ошибки, предупреждения).
- **MvView** — материализованное представление; может состоять из нескольких частей (MvViewExpr), объединённых UNION ALL.
- **MvViewExpr** — одна часть MV: SQL-трансформация в виде соединения таблиц, проекции и опционального фильтра.
- **MvJoinSource** — одна из таблиц в составе SQL-трансформации.
- **MvJoinCondition** — условие соединения (AND в составе MvJoinSource для правой части).
- **MvComputation** — метод вычисления поля или условия (в т.ч. непрозрачное выражение YQL в `#[ ... ]#`).
- **MvLiteral** — целочисленная или строковая константа.
- **MvColumn** — описание выходной колонки и способа её получения.
- **MvHandler** — задание: список MV и входных таблиц с changefeed (STREAM/BATCH), опционально CONSUMER.
- **MvTableInfo**, **MvKeyInfo**, **MvKeyPrefix**, **MvKey** — метаданные таблиц и ключей.
- **MvIssue** — ошибка или предупреждение при разборе/валидации.
- **MvHandlerSettings**, **MvDictionarySettings**, **MvScanSettings** — настройки обработки (потоки, очереди, таймауты, партиционирование и т.д.).

### Парсер конфигурационного формата

Реализован на ANTLR v4 (грамматика `YdbMatViewV1.g4`). Разбирает SQL-подобный скрипт в объекты модели (MvView, MvHandler). Загрузка конфигурации — из файла или из таблицы YDB (настройки см. в README). Класс `MvConfigReader` вызывает парсер и возвращает `MvMetadata`.

### Валидатор конфигурации

После парсинга выполняется привязка к метаданным таблиц YDB через `MvDescriber` (MvDescriberYdb): загрузка описаний таблиц, связывание с MvJoinSource, проверка колонок и типов. Валидация выполняется в два этапа:

1. **MvValidateBasic** — структурные проверки без обращения к БД (ссылки на таблицы/колонки, согласованность).
2. **MvValidateSql** — для каждой части MV генерируются фрагменты SQL (SELECT по ключам, WHERE, выражения колонок) и проверяются выполнением на YDB (синтаксис и корректность). Критические ошибки останавливают дальнейшие фазы.

Вызов: `MvMetadata.linkAndValidate(MvDescriber)` (сначала заполняет `tables`, затем `validate(conn)`).

Ограничения/недоделки:
- Нет отдельного автомата проверки всех вариантов генерируемых запросов и методов доступа при различных сценариях соединений.

### Компонент сбора изменений

- **CDC**: чтение из топиков CDC (MvCdcFeeder, MvCdcAdapter, MvCdcEventReader, MvCdcParser), фиксация позиции через MvCdcCommitHandler.
- **Сканирование**: чтение ключей "самой левой" таблицы MV с ограничением интенсивности (MvScanFeeder, MvScanContext, MvScanCompletion), опциональный фильтр; позиция хранится в таблице (см. README). В распределённом режиме — таблица заданий на сканирование (MvJobDao, MvJobScanInfo).

### Компонент применения изменений

В рамках одного обработчика (MvHandler) активна обработка для набора MV. Обработку конкретного MV можно включать/выключать через API (startHandler/stopHandler — см. MvApi).

Используется N потоков (MvApplyWorker), у каждого своя входная очередь. Ключи "самой левой" таблицы распределяются по воркерам по значению первичного ключа (MvWorkerSelector). Очередь имеет ограничение по размеру в нормальном режиме; форсированный режим используется для внутренних преобразований (дозагрузка ключей, трансформации в памяти), чтобы избежать взаимоблокировок.

Периодически выполняется Describe "самой левой" таблицы и обновляются диапазоны ключей по воркерам (партиционирование RANGE/HASH).

Цикл обработчика:
1. Получить записи об изменениях из очереди (не более K штук).
2. Сгруппировать по таблицам и объектам подтверждения.
3. Определить состав обработчиков (список действий) и подать записи.
4. Подтвердить обработку (фиксация).

Типы действий (MvApplyAction):
- **ActionSync** — чтение данных по ключам (отдельная читающая транзакция), ожидание завершения предыдущей записи при необходимости, запись через `UPSERT INTO mv SELECT * FROM AS_TABLE($input)`.
- **ActionKeysTransform** — трансформация ключей без доступа к БД.
- **ActionKeysGrab** — чтение ключей из БД дополнительным запросом.
- **ActionKeysFilter** — фильтрация ключей.

### Генератор SQL-запросов

**MvSqlGen**: строит SQL на основе MvViewExpr — CREATE TABLE для MV, SELECT по ключам для чтения исходных данных, UPSERT из AS_TABLE. Поддерживает перестроение связей (порядок JOIN) для производных запросов. Вспомогательные константы: SYS_KEYS, SYS_INPUT и др. Типы ключей и строк (StructType) выводятся из модели.

### Генератор путей ключей (MvPathGenerator)

**MvPathGenerator** строит минимальные трансформации между источниками MV на основе графа соединений (MvJoinSource, MvJoinCondition). Использует BFS (Breadth-First Search, поиск в ширину) для поиска путей между таблицами. Основные методы:

- **extractKeysReverse(point)** — строит MvViewExpr, преобразующий первичный ключ указанного источника (`point`) в ключ «самой левой» таблицы (topmost source). Возвращает минимальный набор JOIN, необходимый для трансформации. Используется в MvApply при конфигурации цепочек действий (ActionKeysGrab, ActionKeysTransform) и в MvValidateBasic для проверки достижимости ключей.

- **applyFilter(filter)** — строит MvViewExpr с подмножеством источников и колонок, заданных фильтром. Фильтр — список `FilterItem` (источник + имена полей). Включает только те MvJoinSource, которые лежат на путях от topmost к запрошенным источникам. Соединения — MAIN для первого источника, LEFT для остальных (чтобы учитывать отсутствующие строки при фильтрации). Используется в **MvChangesMultiDict.toFilter()** для построения трансформации при обновлении MV по изменениям справочников.

- **makeDictTrans()** — частный случай `applyFilter`: возвращает трансформацию с ключами topmost-таблицы и всеми BATCH-справочниками, участвующими в JOIN. Порядок колонок соответствует порядку источников в исходном MV. Результат сохраняется в `MvApply.Target.dictTrans` и используется **ActionKeysFilter** для SQL-запроса при фильтрации строк по изменениям справочников.

Вспомогательные классы: **Filter** (`newFilter()`, `add(source, fieldNames)`), **FilterItem** (источник + массив имён полей). Граф соединений строится по MvJoinCondition (двунаправленные рёбра между связанными источниками).

### Сбор изменений справочников

Для таблиц-справочников, используемых в MV, CDC-потоки собираются в режиме BOTH_IMAGES или UPDATES. Изменения записываются в таблицу-журнал (MvDictionaryLogger): таблица-источник, метка времени, первичный ключ, изменённые поля (настройки журнала и потребителя — в README). На журнал рекомендуется TTL. Сбор выполняется централизованно в рамках задания **ydbmv$dictionary** (MvConfig.HANDLER_DICTIONARY).

### Агрегатор изменений справочников

**MvDictionaryScan**: читает журнал изменений справочников, определяет затронутые ключи основного потока и передаёт их в конвейер применения для соответствующего обработчика. Используются запросы с пагинацией по (src, tv, seqno, key_text).

### Внутренняя логика обработки справочников (источников с режимом BATCH)

Ниже описан полный цикл обработки изменений справочников — от сбора до обновления MV. Это три последовательные фазы: сбор и хранение изменений, периодическая проверка журнала, запуск и выполнение сканирования с фильтрацией данных.

#### 1. Сбор и хранение изменений

**MvDictionaryLogger** (активируемый запуском задания `ydbmv$dictionary`) подключается к CDC-потокам всех справочников, участвующих в MV (таблицы-источники в режиме BATCH). События CDC приходят через **MvCdcFeeder** и обрабатываются методом `submit()`: записи преобразуются в структуры `(src, tv, seqno, key_text, key_val, diff_val)` и батчами записываются в таблицу-журнал (параметр `job.dict.hist.table`).

- `src` — имя таблицы-источника
- `tv` — метка времени изменения
- `seqno` — порядковый номер в рамках логгера
- `key_text` — текстовое представление первичного ключа
- `key_val` — JSON первичного ключа
- `diff_val` — JSON со списком изменённых полей (имена колонок), формат: `{"f": ["имя_колонки_1", ...]}`

На таблицу-журнал рекомендуется настроить TTL. Сбор выполняется централизованно (одним заданием `ydbmv$dictionary`) для всех обработчиков.

#### 2. Периодическая проверка журнала

В каждом **MvJobController** (на каждое задание-обработчик) планировщик `scheduleAtFixedRate` каждые 10 секунд вызывает `analyzeDictionaryChecks()`. Фактическая проверка журнала (`performDictionaryChecks`) выполняется не чаще, чем раз в `dictionaryScanSeconds` секунд (настройка **MvHandlerSettings**, параметр `job.dict.scan.seconds`, значение по умолчанию 28800 — 8 часов).

При срабатывании проверки:

1. Создаётся экземпляр агрегатора изменений **MvDictionaryScan** для данного обработчика.
2. **Чтение журнала**: для каждого справочника (BATCH-источника из `handler.getInputs()`) вызывается `scan(tableName)`. Журнал читается с пагинацией по `(src, tv, seqno, key_text)` порциями до 500 строк. Позиция хранится в control-таблице (`job.scan.table`) с ключом `(job_name, table_name)` — `job_name` = имя обработчика, `table_name` = имя справочника. Чтение ограничено `maxChangeRowsScanned` (MvDictionarySettings, параметр `job.max.row.changes`, по умолчанию 100000).
3. Строки журнала разбираются: из `diff_val` извлекаются имена изменённых полей, из `key_val` — ключ строки справочника. Результат накапливается в **MvChangesSingleDict** (таблица → поле → множество ключей затронутых строк).
4. Собранные изменения объединяются в **MvChangesMultiDict**.
5. Если изменений нет или они не релевантны — позиции чтения журнала немедленно сохраняются в актуальное значение, и проверка завершается.
6. Если уже выполняется другая операция сканирования — проверка откладывается.

#### 3. Построение фильтров и запуск сканирования

Для выявленных релевантных изменений выполняется построение фильтра для использования при последующем сканировании:

- Для каждой UNION-части MV (**MvViewExpr**) определяется, какие колонки справочников используются: в условиях JOIN, в проекции, в фильтре (`getColumnUsage()`).
- Для каждого справочника проверяется пересечение: изменённые поля ∩ используемые колонки. Если пересечение непустое — ключи затронутых строк добавляются в множество для фильтрации (блоки **MvRowFilter.Block**).
- Строится экземпляр **MvRowFilter**, в состав которого включается сформированная SQL-трансформация (вывод **MvPathGenerator.applyFilter()**, минимальный путь от «самой левой» таблицы к справочникам) и «блоки» — множества кортежей ключей справочников для фильтрации.

Для сформированного непустого фильтра (под каждую часть MV):

1. Создаётся экземпляр **ActionKeysFilter** со сформированным SQL-выражением для загрузки полей и заданным набором проверяемых кортежей.
2. Запускается **MvScanFeeder**, который обеспечивает поставку ключей для соответствующей части MV.
3. В качестве обработчика завершения сканирований устанавливается экземпляр **DictScanComplete** (см. далее подпункт 5).

#### 4. Выполнение сканирования и фильтрация данных

**MvScanFeeder** сканирует «самую левую» таблицу MV (topmost source), читая ключи постранично. Для каждой порции ключей вызывается `sink.submitCustom(actions, output, handler)` — ключи передаются в **MvApplyManager** и попадают в очереди воркеров apply, где их обрабатывает **ActionKeysFilter**.

**ActionKeysFilter** выполняет:

1. **Чтение**: SQL-запрос для загрузки необходимых полей — JOIN от ключей «самой левой» таблицы (полученных от **MvScanFeeder**) к справочникам. В результате получаются строки, в которых присутствуют ключи и самой «левой» таблицы, и справочников.
2. **Фильтрация**: для каждой строки вызывается проверка соответствия заданному фильтру - `filter.matches(row)`. Поля строки анализируются в порядке, заданном трансформацией; для каждого блока фильтра проверяется, входит ли соответствующий подкортеж (ключи справочника) в множество отобранных фильтром значений. Если хотя бы один блок совпал — строка считается релевантной.
3. **Отправка**: релевантные строки преобразуются в `MvChangeRecord` (ключ «самой левой» таблицы) и передаются через `submitFilter()` в конвейер применения — цепочку **getRefreshActions()**, которая включает **ActionSync** (чтение полных данных по ключам и UPSERT в MV).

Таким образом, обновляются только те строки MV, которые действительно затронуты изменениями в справочниках (через JOIN), а не вся таблица.

Необходимо учитывать, что вычитываются первичные ключи и связанные ключи справочников для всех записей, т.е. выполняется полное чтение как минимум самой левой таблицы.

#### 5. Фиксация позиции чтения таблицы-журнала

**DictScanComplete** отслеживает завершение всех запущенных сканов с помощью счётчика. Когда все сканы завершены (`counter == 0`) и ни один не прерван (`incomplete == 0`), позиции чтения журнала для каждого справочника сохраняются в control-таблицу. При прерванном скане позиции не обновляются, чтобы при следующей проверке чтение таблицы-журнала было запущено с того же места.

### Распределённый планировщик (MvRunner, MvCoordinator)

- В каждом процессе — экземпляр **MvRunner**: регистрируется в таблице `mv_runners`, периодически обновляет свой статус, опрашивает `mv_commands` и по командам запускает/останавливает обработчики через MvApi (startHandler/stopHandler). Запущенные задания фиксирует в `mv_runner_jobs`.
- **MvCoordinator** должен работать в единственном экземпляре глобально. Лидер выбирается через YDB Coordination (MvLocker) по имени **ydbmv$coordinator** (MvConfig.HANDLER_COORDINATOR). Координатор периодически сканирует `mv_jobs`, `mv_runners`, `mv_runner_jobs`; удаляет неактивных раннеров и связанные записи; добавляет команды в `mv_commands` для запуска недостающих заданий и остановки лишних. Имена **ydbmv$dictionary** и **ydbmv$coordinator** зарезервированы и не должны использоваться для обычных MvHandler.

Настраиваемые имена таблиц и периоды задаются через **MvBatchSettings** (загрузка из Properties; полный список параметров — в README, раздел «Настройки управления»). Схемы таблиц `mv/jobs`, `mv/runners`, `mv/runner_jobs`, `mv/commands`, `mv/job_scans` и описание работы координатора и раннеров — в README, раздел «Распределённое управление заданиями (режим JOB)».

При успешном выполнении команды MvRunner обновляет статус в `mv_commands` на SUCCESS и добавляет/удаляет запись в `mv_runner_jobs`; при ошибке — command_status = ERROR, в command_diag пишется диагностика.

## Мониторинг

Метрики Prometheus реализованы в `tech.ydb.mv.metrics.MvMetrics`. Параметры включения и список метрик — в README (раздел параметров конфигурации → метрики, перечень собираемых метрик). Стек Prometheus + Grafana — в `monitoring/README.md`.

## Встраивание

Публичный API: **MvApi** / **MvService** (`MvApi.newInstance(YdbConnector)`). Использование при встраивании библиотеки и зависимость Maven — в README.
